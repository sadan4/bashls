<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/bash/src/main/kotlin/BashLexer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bash/src/main/kotlin/BashLexer.kt" />
              <option name="updatedContent" value="package bash.lexer&#10;&#10;/**&#10; * A lexer for Bash shell scripts.&#10; * This class tokenizes Bash shell script text into a stream of [BashToken] objects.&#10; */&#10;class BashLexer(private val input: String) {&#10;    private var position: Int = 0&#10;    private var line: Int = 1&#10;    private var column: Int = 1&#10;&#10;    /**&#10;     * Current character under the cursor or null if at end of input.&#10;     */&#10;    private val current: Char?&#10;        get() = if (position &lt; input.length) input[position] else null&#10;&#10;    /**&#10;     * Look ahead one character without consuming it.&#10;     */&#10;    private val peek: Char?&#10;        get() = if (position + 1 &lt; input.length) input[position + 1] else null&#10;&#10;    /**&#10;     * Returns the next token from the input or EOF token if at end of input.&#10;     */&#10;    fun nextToken(): BashToken {&#10;        // Skip whitespace but don't include in token&#10;        skipWhitespace()&#10;&#10;        // Return EOF when we reach the end&#10;        if (current == null) {&#10;            return BashToken(BashTokenType.EOF, &quot;&quot;, position, 0)&#10;        }&#10;&#10;        return when (val c = current!!) {&#10;            // Comments&#10;            '#' -&gt; lexComment()&#10;            &#10;            // Operators&#10;            ';' -&gt; {&#10;                if (peek == ';') {&#10;                    consume() // Consume the current semicolon&#10;                    consume() // Consume the second semicolon&#10;                    BashToken(BashTokenType.DSEMI, &quot;;;&quot;, position - 2, 2)&#10;                } else {&#10;                    consume() // Consume the semicolon&#10;                    BashToken(BashTokenType.SEMICOLON, &quot;;&quot;, position - 1, 1)&#10;                }&#10;            }&#10;            '&amp;' -&gt; {&#10;                consume()&#10;                if (current == '&amp;') {&#10;                    consume()&#10;                    BashToken(BashTokenType.AND_IF, &quot;&amp;&amp;&quot;, position - 2, 2)&#10;                } else {&#10;                    BashToken(BashTokenType.GREATAND, &quot;&amp;&quot;, position - 1, 1)&#10;                }&#10;            }&#10;            '|' -&gt; {&#10;                consume()&#10;                if (current == '|') {&#10;                    consume()&#10;                    BashToken(BashTokenType.OR_IF, &quot;||&quot;, position - 2, 2)&#10;                } else {&#10;                    BashToken(BashTokenType.PIPE, &quot;|&quot;, position - 1, 1)&#10;                }&#10;            }&#10;            '\n' -&gt; {&#10;                consume()&#10;                line++&#10;                column = 1&#10;                BashToken(BashTokenType.NEWLINE, &quot;\\n&quot;, position - 1, 1)&#10;            }&#10;            &#10;            // Redirections&#10;            '&lt;' -&gt; {&#10;                consume()&#10;                when (current) {&#10;                    '&lt;' -&gt; {&#10;                        consume()&#10;                        if (current == '-') {&#10;                            consume()&#10;                            BashToken(BashTokenType.DLESSDASH, &quot;&lt;&lt;-&quot;, position - 3, 3)&#10;                        } else {&#10;                            BashToken(BashTokenType.DLESS, &quot;&lt;&lt;&quot;, position - 2, 2)&#10;                        }&#10;                    }&#10;                    '&amp;' -&gt; {&#10;                        consume()&#10;                        BashToken(BashTokenType.LESSAND, &quot;&lt;&amp;&quot;, position - 2, 2)&#10;                    }&#10;                    '&gt;' -&gt; {&#10;                        consume()&#10;                        BashToken(BashTokenType.LESSGREAT, &quot;&lt;&gt;&quot;, position - 2, 2)&#10;                    }&#10;                    else -&gt; BashToken(BashTokenType.LESS, &quot;&lt;&quot;, position - 1, 1)&#10;                }&#10;            }&#10;            '&gt;' -&gt; {&#10;                consume()&#10;                when (current) {&#10;                    '&gt;' -&gt; {&#10;                        consume()&#10;                        BashToken(BashTokenType.DGREAT, &quot;&gt;&gt;&quot;, position - 2, 2)&#10;                    }&#10;                    '&amp;' -&gt; {&#10;                        consume()&#10;                        BashToken(BashTokenType.GREATAND, &quot;&gt;&amp;&quot;, position - 2, 2)&#10;                    }&#10;                    else -&gt; BashToken(BashTokenType.GREAT, &quot;&gt;&quot;, position - 1, 1)&#10;                }&#10;            }&#10;            &#10;            // Variable expansion and substitution&#10;            '$' -&gt; {&#10;                val startPos = position&#10;                consume()&#10;                when (current) {&#10;                    '{' -&gt; {&#10;                        consume()&#10;                        BashToken(BashTokenType.DOLLARLBRACE, &quot;${&quot;, startPos, 2)&#10;                    }&#10;                    '(' -&gt; {&#10;                        consume()&#10;                        if (current == '(') {&#10;                            consume()&#10;                            BashToken(BashTokenType.DOLLARDBLPARENS, &quot;$((&quot;, startPos, 3)&#10;                        } else {&#10;                            BashToken(BashTokenType.DOLLARPARENS, &quot;$(&quot;, startPos, 2)&#10;                        }&#10;                    }&#10;                    else -&gt; BashToken(BashTokenType.DOLLAR, &quot;$&quot;, startPos, 1)&#10;                }&#10;            }&#10;            &#10;            // Quotes&#10;            '\'' -&gt; {&#10;                val startPos = position&#10;                consume()&#10;                BashToken(BashTokenType.SINGLEQUOTE, &quot;'&quot;, startPos, 1)&#10;            }&#10;            '&quot;' -&gt; {&#10;                val startPos = position&#10;                consume()&#10;                BashToken(BashTokenType.DOUBLEQUOTE, &quot;\&quot;&quot;, startPos, 1)&#10;            }&#10;            '`' -&gt; {&#10;                val startPos = position&#10;                consume()&#10;                BashToken(BashTokenType.BACKQUOTE, &quot;`&quot;, startPos, 1)&#10;            }&#10;            '\\' -&gt; {&#10;                val startPos = position&#10;                consume()&#10;                BashToken(BashTokenType.BACKSLASH, &quot;\\&quot;, startPos, 1)&#10;            }&#10;            &#10;            // Parentheses and brackets&#10;            '(' -&gt; {&#10;                consume()&#10;                BashToken(BashTokenType.LPARENS, &quot;(&quot;, position - 1, 1)&#10;            }&#10;            ')' -&gt; {&#10;                consume()&#10;                BashToken(BashTokenType.RPARENS, &quot;)&quot;, position - 1, 1)&#10;            }&#10;            '{' -&gt; {&#10;                consume()&#10;                BashToken(BashTokenType.LBRACE, &quot;{&quot;, position - 1, 1)&#10;            }&#10;            '}' -&gt; {&#10;                consume()&#10;                BashToken(BashTokenType.RBRACE, &quot;}&quot;, position - 1, 1)&#10;            }&#10;            '[' -&gt; {&#10;                consume()&#10;                BashToken(BashTokenType.LBRACKET, &quot;[&quot;, position - 1, 1)&#10;            }&#10;            ']' -&gt; {&#10;                consume()&#10;                BashToken(BashTokenType.RBRACKET, &quot;]&quot;, position - 1, 1)&#10;            }&#10;            &#10;            // Word - handle keywords, assignments, and general words&#10;            else -&gt; {&#10;                if (isAlphaNumeric(c)) {&#10;                    lexWord()&#10;                } else {&#10;                    // Unknown character&#10;                    val startPos = position&#10;                    consume()&#10;                    BashToken(BashTokenType.UNKNOWN, c.toString(), startPos, 1)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lexes a word token, which could be a keyword, assignment, or normal word.&#10;     */&#10;    private fun lexWord(): BashToken {&#10;        val startPos = position&#10;        val buffer = StringBuilder()&#10;        &#10;        // Collect all alphanumeric, underscore, dash characters&#10;        while (current != null &amp;&amp; (isAlphaNumeric(current!!) || current == '_' || current == '-')) {&#10;            buffer.append(current)&#10;            consume()&#10;        }&#10;        &#10;        // Check if it's an assignment (word=value)&#10;        if (current == '=' &amp;&amp; buffer.isNotEmpty()) {&#10;            buffer.append(current)&#10;            consume()&#10;            return BashToken(BashTokenType.ASSIGNMENT_WORD, buffer.toString(), startPos, buffer.length)&#10;        }&#10;        &#10;        // Check if it's a keyword&#10;        val word = buffer.toString()&#10;        val type = when (word) {&#10;            &quot;if&quot; -&gt; BashTokenType.IF&#10;            &quot;then&quot; -&gt; BashTokenType.THEN&#10;            &quot;else&quot; -&gt; BashTokenType.ELSE&#10;            &quot;elif&quot; -&gt; BashTokenType.ELIF&#10;            &quot;fi&quot; -&gt; BashTokenType.FI&#10;            &quot;do&quot; -&gt; BashTokenType.DO&#10;            &quot;done&quot; -&gt; BashTokenType.DONE&#10;            &quot;case&quot; -&gt; BashTokenType.CASE&#10;            &quot;esac&quot; -&gt; BashTokenType.ESAC&#10;            &quot;while&quot; -&gt; BashTokenType.WHILE&#10;            &quot;until&quot; -&gt; BashTokenType.UNTIL&#10;            &quot;for&quot; -&gt; BashTokenType.FOR&#10;            &quot;in&quot; -&gt; BashTokenType.IN&#10;            &quot;function&quot; -&gt; BashTokenType.FUNCTION&#10;            &quot;select&quot; -&gt; BashTokenType.SELECT&#10;            &quot;time&quot; -&gt; BashTokenType.TIME&#10;            &quot;coproc&quot; -&gt; BashTokenType.COPROC&#10;            else -&gt; BashTokenType.WORD&#10;        }&#10;        &#10;        return BashToken(type, word, startPos, word.length)&#10;    }&#10;&#10;    /**&#10;     * Lexes a comment token.&#10;     */&#10;    private fun lexComment(): BashToken {&#10;        val startPos = position&#10;        val buffer = StringBuilder()&#10;        &#10;        // Consume the '#'&#10;        buffer.append(current)&#10;        consume()&#10;        &#10;        // Read until end of line or end of input&#10;        while (current != null &amp;&amp; current != '\n') {&#10;            buffer.append(current)&#10;            consume()&#10;        }&#10;        &#10;        val comment = buffer.toString()&#10;        return BashToken(BashTokenType.COMMENT, comment, startPos, comment.length)&#10;    }&#10;&#10;    /**&#10;     * Advances the cursor position by one character.&#10;     */&#10;    private fun consume(): Char? {&#10;        if (position &gt;= input.length) return null&#10;        &#10;        val c = input[position]&#10;        position++&#10;        column++&#10;        return c&#10;    }&#10;&#10;    /**&#10;     * Skips whitespace characters (except newlines).&#10;     */&#10;    private fun skipWhitespace() {&#10;        while (current != null &amp;&amp; current!!.isWhitespace() &amp;&amp; current != '\n') {&#10;            consume()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Returns true if the character is alphanumeric.&#10;     */&#10;    private fun isAlphaNumeric(c: Char): Boolean {&#10;        return c.isLetterOrDigit()&#10;    }&#10;&#10;    /**&#10;     * Tokenizes the entire input and returns a list of tokens.&#10;     */&#10;    fun tokenize(): List&lt;BashToken&gt; {&#10;        val tokens = mutableListOf&lt;BashToken&gt;()&#10;        var token = nextToken()&#10;        &#10;        while (token.type != BashTokenType.EOF) {&#10;            tokens.add(token)&#10;            token = nextToken()&#10;        }&#10;        &#10;        // Add the EOF token&#10;        tokens.add(token)&#10;        &#10;        return tokens&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bash/src/main/kotlin/BashToken.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bash/src/main/kotlin/BashToken.kt" />
              <option name="updatedContent" value="package bash.lexer&#10;&#10;/**&#10; * Represents the different types of tokens in Bash syntax.&#10; */&#10;enum class BashTokenType {&#10;    // Keywords&#10;    IF, THEN, ELSE, ELIF, FI, DO, DONE, CASE, ESAC, WHILE, UNTIL, FOR, IN, &#10;    FUNCTION, SELECT, TIME, COPROC,&#10;    &#10;    // Control operators&#10;    SEMICOLON, AND_IF, OR_IF, DSEMI, NEWLINE, PIPE,&#10;    &#10;    // Redirections&#10;    LESS, GREAT, DLESS, DGREAT, LESSAND, GREATAND, LESSGREAT, DLESSDASH,&#10;    &#10;    // Expansions&#10;    DOLLAR, DOLLARLBRACE, DOLLARPARENS, DOLLARDBLPARENS,&#10;    &#10;    // Quotes and escaping&#10;    SINGLEQUOTE, DOUBLEQUOTE, BACKQUOTE, BACKSLASH,&#10;    &#10;    // Parentheses and brackets&#10;    LPARENS, RPARENS, LBRACE, RBRACE, LBRACKET, RBRACKET,&#10;    &#10;    // Literals&#10;    WORD, ASSIGNMENT_WORD, NAME, NUMBER,&#10;    &#10;    // Special&#10;    COMMENT, WHITESPACE, EOF, UNKNOWN,&#10;    &#10;    // Command substitution&#10;    COMMAND_SUB_START, COMMAND_SUB_END&#10;}&#10;&#10;/**&#10; * Represents a token in the Bash syntax.&#10; *&#10; * @property type The type of the token.&#10; * @property value The string value of the token.&#10; * @property position The position in the source code where this token starts.&#10; * @property length The length of the token.&#10; */&#10;data class BashToken(&#10;    val type: BashTokenType,&#10;    val value: String,&#10;    val position: Int,&#10;    val length: Int&#10;) {&#10;    val endPosition: Int&#10;        get() = position + length&#10;        &#10;    override fun toString(): String = &quot;Token($type, '$value', pos=$position, len=$length)&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bash/src/main/kotlin/zip/sadan/bashls/bash/lexer/tokens/here/HeredocEndToken.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bash/src/main/kotlin/zip/sadan/bashls/bash/lexer/tokens/here/HeredocEndToken.kt" />
              <option name="originalContent" value="package zip.sadan.bashls.bash.lexer.tokens.here&#10;&#10;import zip.sadan.bashls.bash.lexer.Range&#10;import zip.sadan.bashls.bash.lexer.tokens.Token&#10;import zip.sadan.bashls.bash.lexer.tokens.whitespace.BlankSpaceToken&#10;&#10;class HeredocEndToken(override val pos: Range, override val delimiter: List&lt;Token&gt;) : HeredocToken() {&#10;    override val padding: BlankSpaceToken? = null&#10;    override val tok: String = &quot;&quot;&#10;}" />
              <option name="updatedContent" value="package zip.sadan.bashls.bash.lexer.tokens.here&#10;&#10;import zip.sadan.bashls.bash.lexer.Range&#10;import zip.sadan.bashls.bash.lexer.tokens.Token&#10;import zip.sadan.bashls.bash.lexer.tokens.whitespace.BlankSpaceToken&#10;&#10;class HeredocEndToken(override val pos: Range, override val delimiter: List&lt;Token&gt;) : HeredocToken() {&#10;    override val padding: BlankSpaceToken? = null&#10;    override val tok: String = &quot;&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bash/src/main/kotlin/zip/sadan/bashls/bash/lexer/tokens/redir/RedirToken.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bash/src/main/kotlin/zip/sadan/bashls/bash/lexer/tokens/redir/RedirToken.kt" />
              <option name="originalContent" value="package zip.sadan.bashls.bash.lexer.tokens.redir&#10;&#10;import zip.sadan.bashls.bash.lexer.tokens.Token&#10;&#10;interface RedirToken : Token" />
              <option name="updatedContent" value="package zip.sadan.bashls.bash.lexer.tokens.redir&#10;&#10;import zip.sadan.bashls.bash.lexer.tokens.Token&#10;&#10;abstract class RedirToken : Token()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bash/src/main/kotlin/zip/sadan/bashls/bash/lexer/tokens/test/StringEqualTestToken.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bash/src/main/kotlin/zip/sadan/bashls/bash/lexer/tokens/test/StringEqualTestToken.kt" />
              <option name="originalContent" value="package zip.sadan.bashls.bash.lexer.tokens.test&#10;&#10;import zip.sadan.bashls.bash.lexer.Range&#10;&#10;/**&#10; * ```bash&#10; * [ &quot;$a&quot; = &quot;$b&quot; ]&#10; * [ &quot;$a&quot; == &quot;$b&quot; ]&#10; * ```&#10; */&#10;class StringEqualTestToken(override val pos: Range) : TestToken {&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package zip.sadan.bashls.bash.lexer.tokens.test&#10;&#10;import zip.sadan.bashls.bash.lexer.Range&#10;&#10;/**&#10; * ```bash&#10; * [ &quot;$a&quot; = &quot;$b&quot; ]&#10; * [ &quot;$a&quot; == &quot;$b&quot; ]&#10; * ```&#10; */&#10;class StringEqualTestToken(override val pos: Range) : TestToken() {&#10;    override val contents: String = &quot;=&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bash/src/main/kotlin/zip/sadan/bashls/bash/lexer/tokens/whitespace/NewlineToken.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bash/src/main/kotlin/zip/sadan/bashls/bash/lexer/tokens/whitespace/NewlineToken.kt" />
              <option name="originalContent" value="package zip.sadan.bashls.bash.lexer.tokens.whitespace&#10;&#10;import zip.sadan.bashls.bash.lexer.Range&#10;&#10;/**&#10; * A single newline&#10; */&#10;class NewlineToken(override val pos: Range) : WhitespaceToken() {&#10;    override val contents: String = &quot;\n&quot;&#10;}" />
              <option name="updatedContent" value="package zip.sadan.bashls.bash.lexer.tokens.whitespace&#10;&#10;import zip.sadan.bashls.bash.lexer.Range&#10;&#10;/**&#10; * A single newline&#10; */&#10;class NewlineToken(override val pos: Range) : WhitespaceToken() {&#10;    override val contents: String = &quot;\n&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/src/main/kotlin/zip/sadan/bashls/util/collections/list/asPair.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/src/main/kotlin/zip/sadan/bashls/util/collections/list/asPair.kt" />
              <option name="originalContent" value="package zip.sadan.bashls.util.collections.list&#10;&#10;fun &lt;T&gt; List&lt;T&gt;.asPair(): Pair&lt;T, T&gt; {&#10;    if (size != 2) {&#10;        error(&quot;list must have size to to convert to pair. got size: $size&quot;)&#10;    }&#10;    return first() to last()&#10;}" />
              <option name="updatedContent" value="package zip.sadan.bashls.util.collections.list&#10;&#10;fun &lt;T&gt; List&lt;T&gt;.asPair(): Pair&lt;T, T&gt; {&#10;    if (size != 2) {&#10;        error(&quot;list must have size to to convert to pair. got size: $size&quot;)&#10;    }&#10;    return first() to last()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>